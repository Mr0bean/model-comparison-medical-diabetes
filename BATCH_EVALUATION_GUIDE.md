# 分批次评估使用指南

## 📋 批次设置

系统已预设3个批次，合理分配评估任务：

| 批次 | 患者 | 数量 | API调用数 |
|------|------|------|-----------|
| **第一批** | 患者2, 患者3, 患者4 | 3 | 3×64 = 192 |
| **第二批** | 患者5, 患者6, 患者7 | 3 | 3×64 = 192 |
| **第三批** | 患者8, 患者9, 患者10 | 3 | 3×64 = 192 |
| **总计** | 9个患者 | 9 | **576次** |

> 💡 为什么跳过患者1？建议先用患者1做测试验证

---

## 🚀 快速使用

### 方式1：交互式执行（推荐）

```bash
python run_batch_evaluation.py
```

**交互流程**：
1. 显示批次设置
2. 询问是否继续
3. 选择执行模式：
   - `1` - 全部执行（所有3批）
   - `2` - 仅第一批（患者2,3,4）
   - `3` - 仅第二批（患者5,6,7）
   - `4` - 仅第三批（患者8,9,10）
   - `5` - 试运行（仅显示命令）
4. 开始执行

**示例输出**：
```
📊 分批次交叉评估系统
================================================================================

批次设置:
  1. 第一批: 患者2, 患者3, 患者4
  2. 第二批: 患者5, 患者6, 患者7
  3. 第三批: 患者8, 患者9, 患者10

总患者数: 9
总批次数: 3
预计总API调用: 576 次

是否开始执行？(y/n): y

执行模式:
  1. 全部执行（所有3批）
  2. 仅第一批（患者2,3,4）
  3. 仅第二批（患者5,6,7）
  4. 仅第三批（患者8,9,10）
  5. 试运行（仅显示命令）

选择模式 (1-5): 1

================================================================================
进度: 1/3
================================================================================

🚀 开始执行: 第一批
================================================================================
患者列表: 患者2, 患者3, 患者4
患者数量: 3
预计API调用: 3 × 8 × 8 = 192 次
================================================================================

执行命令: python run_cross_evaluation.py --patients 患者2 患者3 患者4

[开始评估...]
```

---

## 📊 执行模式说明

### 模式1：全部执行（推荐夜间运行）

```
选择: 1

执行流程:
  第一批（患者2,3,4）→ 等待5秒 → 第二批（患者5,6,7）→ 等待5秒 → 第三批（患者8,9,10）

预计时间:
  - 每批约 40-50 分钟
  - 总计约 2-2.5 小时
```

### 模式2-4：单批执行（分段执行）

```
选择: 2  # 仅执行第一批

执行流程:
  第一批（患者2,3,4）

预计时间:
  - 约 40-50 分钟

适用场景:
  ✅ 分时段执行，避免长时间占用
  ✅ 测试单个批次
  ✅ 从某一批次恢复执行
```

### 模式5：试运行（调试用）

```
选择: 5

执行流程:
  仅显示将要执行的命令，不实际调用API

输出示例:
  执行命令: python run_cross_evaluation.py --patients 患者2 患者3 患者4
  ⚠️  试运行模式，不实际执行
```

---

## 🎯 推荐执行策略

### 策略A：完整执行（一次性完成）

```bash
# 适合：夜间或周末执行
python run_batch_evaluation.py
# 选择: 1 (全部执行)

# 预计耗时: 2-2.5小时
# 优点: 一次性完成所有评估
# 缺点: 需要等待较长时间
```

### 策略B：分段执行（工作时段）

```bash
# 上午执行第一批
python run_batch_evaluation.py
# 选择: 2

# 下午执行第二批
python run_batch_evaluation.py
# 选择: 3

# 晚上执行第三批
python run_batch_evaluation.py
# 选择: 4

# 优点: 灵活安排时间
# 缺点: 需要多次操作
```

### 策略C：测试优先（谨慎执行）

```bash
# 1. 先用患者1测试
python run_cross_evaluation.py --test-mode

# 2. 确认无误后，执行第一批
python run_batch_evaluation.py
# 选择: 2

# 3. 检查第一批结果
ls output/cross_evaluation_results/患者2/conv_1_主诉/raw/

# 4. 确认正常后，继续执行其他批次
python run_batch_evaluation.py
# 选择: 3

# 优点: 风险最低，逐步验证
# 缺点: 需要更多人工介入
```

---

## ⏱️ 时间预估

### 单个患者评估时间

```
1个患者 × 5个对话 × 8×8评估 = 320次API调用
平均响应时间: 4秒
总时间: 320 × 4秒 = 1280秒 ≈ 21分钟
```

### 各批次预估时间

| 批次 | 患者数 | API调用 | 预计时间 |
|------|--------|---------|----------|
| 第一批 | 3 | 192 | 40-50分钟 |
| 第二批 | 3 | 192 | 40-50分钟 |
| 第三批 | 3 | 192 | 40-50分钟 |
| **总计** | **9** | **576** | **2-2.5小时** |

> 💡 实际时间可能因网络和API响应速度有所不同

---

## 📁 输出文件

### 执行过程中

```
output/cross_evaluation_results/
├── 患者2/
│   └── conv_1_主诉/
│       └── raw/
│           ├── gpt-5.1_by_deepseek.json
│           └── ...
├── 患者3/
├── 患者4/
...
```

### 执行日志

```
batch_evaluation_log_20251118_210000.txt

内容示例:
分批次评估执行日志
执行时间: 2025-11-18 21:00:00
总耗时: 125.3 分钟

第一批:
  状态: success
  患者: 患者2, 患者3, 患者4
  耗时: 42.1 分钟

第二批:
  状态: success
  患者: 患者5, 患者6, 患者7
  耗时: 41.8 分钟
...
```

---

## 🔄 中断与恢复

### 如果执行中断

**场景1：第一批完成后中断**
```bash
# 系统已保存第一批的raw文件
# 重新执行时选择模式3（第二批）继续

python run_batch_evaluation.py
选择: 3  # 从第二批开始
```

**场景2：批次执行中中断**
```bash
# 已评估的会被缓存
# 重新执行该批次，自动跳过已完成的

python run_batch_evaluation.py
选择: 2  # 重新执行第一批（自动跳过已完成的）
```

**场景3：某批次失败**
```bash
# 程序会询问是否继续下一批
批次执行失败，是否继续下一批？(y/n): y

# 或手动重新执行失败的批次
python run_batch_evaluation.py
选择: 2  # 重试第一批
```

---

## 🛠️ 高级用法

### 自定义批次

编辑 `run_batch_evaluation.py` 文件：

```python
# 修改第17-29行
PATIENT_BATCHES = [
    {
        "name": "第一批",
        "patients": ["患者1", "患者2"]  # 自定义患者列表
    },
    {
        "name": "第二批",
        "patients": ["患者3", "患者4", "患者5"]
    },
    # 可以添加更多批次
]
```

### 指定对话类型

```python
# 在run_evaluation_for_batch函数中添加对话类型参数
cmd = [
    "python", "run_cross_evaluation.py",
    "--patients"
] + patients + [
    "--conversations", "1", "2"  # 只评估对话1和2
]
```

---

## 📊 完整工作流程

### 第一步：收集原始响应（分批执行）

```bash
# 方式A：一次性执行全部3批
python run_batch_evaluation.py
选择: 1

# 方式B：分3次执行
python run_batch_evaluation.py  # 选择: 2
python run_batch_evaluation.py  # 选择: 3
python run_batch_evaluation.py  # 选择: 4
```

**预计耗时**：2-2.5小时

---

### 第二步：解析原始响应

```bash
# 解析所有批次的原始响应
python parse_raw_responses.py
```

**预计耗时**：5-10分钟

---

### 第三步：生成评分矩阵

```bash
# 使用已解析的数据生成矩阵
python run_cross_evaluation.py --skip-evaluation
```

**预计耗时**：1-2分钟

---

## 💡 最佳实践

### ✅ 推荐做法

1. **先测试**：用患者1测试完整流程
   ```bash
   python run_cross_evaluation.py --test-mode
   ```

2. **分批执行**：根据时间安排选择批次
   ```bash
   python run_batch_evaluation.py  # 选择对应批次
   ```

3. **定期检查**：执行过程中查看进度
   ```bash
   # 另开终端查看已完成数量
   find output/cross_evaluation_results -name "*.json" -path "*/raw/*" | wc -l
   ```

4. **备份数据**：定期备份raw目录
   ```bash
   tar -czf raw_backup_$(date +%Y%m%d).tar.gz \
       output/cross_evaluation_results/*/*/raw/
   ```

### ❌ 避免做法

1. ❌ 不要同时运行多个批次（会冲突）
2. ❌ 不要修改正在执行的批次配置
3. ❌ 不要在执行过程中删除output目录
4. ❌ 不要忽略错误继续执行

---

## 🔍 监控与调试

### 实时监控进度

```bash
# 终端1：运行评估
python run_batch_evaluation.py

# 终端2：监控文件数量
watch -n 10 'find output/cross_evaluation_results -name "*.json" -path "*/raw/*" | wc -l'
```

### 查看当前进度

```bash
# 统计已完成的raw文件
find output/cross_evaluation_results -name "*.json" -path "*/raw/*" | wc -l

# 预期总数: 576 (9个患者 × 64次评估)
```

### 检查失败的评估

```bash
# 查看执行日志
cat batch_evaluation_log_*.txt

# 查看具体批次的输出
python run_cross_evaluation.py --patients 患者2 患者3 患者4
```

---

## 📞 故障排查

### 问题1：批次执行失败

**现象**：某个批次执行失败，返回错误

**解决**：
1. 查看错误信息
2. 检查API密钥是否有效
3. 检查网络连接
4. 重新执行该批次

```bash
# 单独执行失败的批次
python run_batch_evaluation.py
选择: 2  # 重试第一批
```

### 问题2：中断后如何继续

**现象**：执行过程中按Ctrl+C中断

**解决**：
```bash
# 重新执行，系统会自动跳过已完成的
python run_batch_evaluation.py
选择相应批次  # 从中断的批次继续
```

### 问题3：API限流

**现象**：出现429错误（Too Many Requests）

**解决**：
1. 等待几分钟
2. 重新执行（会自动跳过已完成的）
3. 考虑增加批次间等待时间

---

## 📈 性能优化

### 调整批次大小

如果单批次耗时过长，可以拆分为更小的批次：

```python
PATIENT_BATCHES = [
    {"name": "第一批", "patients": ["患者2", "患者3"]},      # 2个患者
    {"name": "第二批", "patients": ["患者4", "患者5"]},      # 2个患者
    {"name": "第三批", "patients": ["患者6", "患者7"]},      # 2个患者
    {"name": "第四批", "patients": ["患者8"]},              # 1个患者
    {"name": "第五批", "patients": ["患者9", "患者10"]},    # 2个患者
]
```

### 调整等待时间

修改第231行的等待时间：

```python
wait_time = 5  # 改为10秒或更长，避免API限流
```

---

## 🎯 总结

**分批执行的优势**：
- ✅ 灵活安排时间，不需要一次性完成
- ✅ 降低风险，单批失败不影响其他批次
- ✅ 便于监控和调试
- ✅ 支持断点续传

**使用建议**：
1. 首次使用选择**模式5（试运行）**熟悉流程
2. 正式执行选择**模式2-4（单批）**逐批验证
3. 熟练后选择**模式1（全部）**一次性完成

---

**版本**: v1.0
**更新日期**: 2025-11-18
**适用范围**: 大规模交叉评估任务
